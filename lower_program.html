<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BitGrid LUT/Program Viewer</title>
  <style>
    :root { --bg:#0b0d12; --fg:#e6e6e6; --muted:#9aa0aa; --card:#11151c; --border:#30384a; }
    html, body { height:100%; }
    body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; color: var(--fg); background: var(--bg); display:flex; height:100%; }
    #grid { flex: 2 1 0; overflow: auto; padding: 12px; }
    #side { flex: 1 1 360px; border-left: 1px solid var(--border); padding: 12px; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
    .gridwrap { display:grid; gap:4px; }
    .cell { box-sizing: border-box; border: 1px solid var(--border); padding: 4px; background: var(--card); cursor: pointer; }
    .cell.empty { opacity: .25; cursor: default; }
    .coords { color:#7aa2f7; font-size:11px; }
    .dirs { margin-top:4px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 11px; line-height: 1.25; }
    .dir { display:inline-block; margin-right: 6px; }
    .N { color:#5fd7ff; } .E { color:#ffd75f; } .S { color:#87ff87; } .W { color:#ff87ff; }
    .pill { display:inline-block; background:#1e2430; border:1px solid #394057; border-radius:12px; padding:2px 8px; font-size:11px; margin-right:6px; }
    .muted { color: var(--muted); }
    .dropzone { border:1px dashed var(--border); border-radius:6px; padding:6px 10px; color:var(--muted); }
    input[type="text"]{ background:#0f131a; border:1px solid var(--border); color:var(--fg); padding:6px 8px; border-radius:6px; width: 320px; }
    input[type="file"]{ color:var(--muted); }
    button{ background:#2b3344; color:#e6e6e6; border:1px solid #3d465a; border-radius:6px; padding:6px 10px; cursor:pointer; }
    button:hover{ filter:brightness(1.1); }
    pre { white-space: pre-wrap; word-break: break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
  </style>
</head>
<body>
  <div id="grid">
    <div class="toolbar">
      <span class="pill">W×H: <span id="wh">-</span></span>
      <label><input type="radio" name="fmt" checked onclick="toggleExpr()"> expr</label>
      <label><input type="radio" name="fmt" onclick="toggleHex()"> hex</label>
      <label><input type="radio" name="fmt" onclick="toggleRaw()"> raw</label>
      <span class="muted">|</span>
      <label><input type="checkbox" checked onchange="setFilter('N', this.checked)"> N</label>
      <label><input type="checkbox" checked onchange="setFilter('E', this.checked)"> E</label>
      <label><input type="checkbox" checked onchange="setFilter('S', this.checked)"> S</label>
      <label><input type="checkbox" checked onchange="setFilter('W', this.checked)"> W</label>
    </div>
    <div class="toolbar">
      <input type="file" accept=".json" onchange="handleFiles(this.files)">
      <div id="drop" class="dropzone">Drop JSON here</div>
      <input id="url" type="text" placeholder="URL or relative path (e.g., out/routed_10x10_parallel8.json)">
      <button onclick="handleURL()">Load URL</button>
    </div>
    <div id="gridwrap" class="gridwrap"></div>
  </div>
  <div id="side">
    <div id="detail" class="muted">Load a JSON (LUTGrid or Program). Click a cell to inspect.</div>
  </div>

  <script>
    function lutToExpr(lut){
      lut = lut & 0xFFFF;
      if (lut === 0) return '0';
      if (lut === 0xFFFF) return '1';
      const f = new Array(16).fill(0).map((_,i)=> (lut>>i)&1);
      for (let i=0;i<4;i++){
        const step = 1<<i;
        for (let m=0;m<16;m++){
          if (m & step){ f[m] ^= f[m ^ step]; }
        }
      }
      const higher = [3,5,6,7,9,10,11,12,13,14,15];
      const hasHigher = higher.some(m => f[m]!==0);
      if (!hasHigher){
        const parts = [];
        if (f[1]) parts.push('N');
        if (f[2]) parts.push('E');
        if (f[4]) parts.push('S');
        if (f[8]) parts.push('W');
        if (parts.length===0) return f[0] ? '1' : '0';
        const xorExpr = parts.length>1 ? parts.join(' ^ ') : parts[0];
        return f[0] ? `!(${xorExpr})` : xorExpr;
      }
      const minterms = [];
      for (let i=0;i<16;i++){ if(((lut>>i)&1)===1) minterms.push(i); }
      const patternFor = (idx)=>['N','E','S','W'].map((_,b)=> ((idx>>b)&1)?'1':'0').join('');
      const combine = (p,q)=>{
        let diff=0; let out='';
        for (let i=0;i<4;i++){
          const a=p[i], b=q[i];
          if (a===b){ out+=a; }
          else{
            if (a==='-'||b==='-') return null;
            diff++; out+='-'; if (diff>1) return null;
          }
        }
        return diff===1 ? out : null;
      };
      let current = new Map(minterms.map(m=>[patternFor(m), new Set([m])]));
      const allPrimes = new Map();
      while (true){
        const used = new Set();
        const next = new Map();
        const pats = Array.from(current.entries());
        for (let i=0;i<pats.length;i++){
          const [pi, covi] = pats[i];
          for (let j=i+1;j<pats.length;j++){
            const [pj, covj] = pats[j];
            const comb = combine(pi,pj);
            if (comb){
              used.add(pi); used.add(pj);
              const cov = new Set([...covi, ...covj]);
              if (next.has(comb)){
                const s = next.get(comb); cov.forEach(v=>s.add(v));
              } else {
                next.set(comb, cov);
              }
            }
          }
        }
        for (const [p,cov] of current.entries()){
          if (!used.has(p)){
            if (allPrimes.has(p)){
              const s = allPrimes.get(p); cov.forEach(v=>s.add(v));
            } else {
              allPrimes.set(p, new Set(cov));
            }
          }
        }
        if (next.size===0) break;
        current = next;
      }
      const minSet = new Set(minterms);
      const chart = new Map();
      minSet.forEach(m=>chart.set(m, new Set()));
      for (const [p,cov] of allPrimes.entries()){
        for (const m of cov){ if (chart.has(m)) chart.get(m).add(p); }
      }
      const selected = [];
      const covered = new Set();
      while (true){
        const essentials = [];
        for (const [m,ps] of chart.entries()){
          if (!covered.has(m) && ps.size===1) essentials.push(m);
        }
        if (essentials.length===0) break;
        for (const m of essentials){
          const p = [...chart.get(m)][0];
          if (!selected.includes(p)) selected.push(p);
          for (const mm of allPrimes.get(p)||[]) covered.add(mm);
        }
      }
      const allPrimesArr = Array.from(allPrimes.entries());
      while (covered.size !== minSet.size){
        let best=null, bestGain=-1;
        for (const [p,cov] of allPrimesArr){
          if (selected.includes(p)) continue;
          let gain=0; for (const m of cov){ if (!covered.has(m)) gain++; }
          if (gain>bestGain){ bestGain=gain; best=p; }
        }
        if (!best || bestGain<=0) break;
        selected.push(best);
        for (const m of allPrimes.get(best)||[]) covered.add(m);
      }
      const names=['N','E','S','W'];
      const termOf = (pat)=>{
        const lits=[];
        for (let i=0;i<4;i++){
          const ch = pat[i];
          if (ch==='-') continue;
          if (ch==='1') lits.push(names[i]); else if (ch==='0') lits.push('!'+names[i]);
        }
        if (lits.length===0) return '1';
        if (lits.length===1) return lits[0];
        return '(' + lits.join(' & ') + ')';
      };
      return selected.map(termOf).sort().join(' | ');
    }

    let MODEL = null;
    let showExpr = true, showHex = false;
    const filter = {N:true,E:true,S:true,W:true};

    function buildModelFromLUTGrid(j){
      const W = Number(j.width), H = Number(j.height);
      const grid = [];
      for (let y=0;y<H;y++){
        const row=[]; for (let x=0;x<W;x++) row.push({x,y,luts:[0,0,0,0]});
        grid.push(row);
      }
      for (const c of (j.cells||[])){
        const x=Number(c.x), y=Number(c.y);
        if (y>=0&&y<H&&x>=0&&x<W){ grid[y][x].luts = [0,0,0,0].map((_,i)=> Number(c.luts?.[i]||0)&0xFFFF); }
      }
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          const luts = grid[y][x].luts;
          grid[y][x].hex = luts.map(v=> (v&0xFFFF).toString(16).toUpperCase().padStart(4,'0'));
          grid[y][x].expr = luts.map(v=> v?lutToExpr(v):'0');
        }
      }
      return {W,H,cells:grid};
    }

    function buildModelFromProgram(j){
      const W = Number(j.width), H = Number(j.height);
      const grid = [];
      for (let y=0;y<H;y++){
        const row=[]; for (let x=0;x<W;x++) row.push({x,y,luts:[0,0,0,0]});
        grid.push(row);
      }
      for (const c of (j.cells||[])){
        const x=Number(c.x), y=Number(c.y);
        const l = c.params && Array.isArray(c.params.luts) ? c.params.luts : null;
        if (l && y>=0&&y<H&&x>=0&&x<W){ grid[y][x].luts = [0,0,0,0].map((_,i)=> Number(l[i]||0)&0xFFFF); }
      }
      for (let y=0;y<H;y++){
        for (let x=0;x<W;x++){
          const luts = grid[y][x].luts;
          grid[y][x].hex = luts.map(v=> (v&0xFFFF).toString(16).toUpperCase().padStart(4,'0'));
          grid[y][x].expr = luts.map(v=> v?lutToExpr(v):'0');
        }
      }
      return {W,H,cells:grid};
    }

    async function loadJSONFromURL(url){
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to fetch: '+res.status);
      return await res.json();
    }

    function tryBuildModel(j){
      if (j && j.format === 'lutgrid-v1' && typeof j.width==='number') return buildModelFromLUTGrid(j);
      if (j && typeof j.width==='number' && Array.isArray(j.cells)) return buildModelFromProgram(j);
      throw new Error('Unrecognized JSON format');
    }

    function renderGrid(){
      const wrap = document.getElementById('gridwrap');
      if (!MODEL){ wrap.innerHTML = '<div class="muted">Load a JSON (LUTGrid or Program) to view.</div>'; document.getElementById('wh').textContent='-'; return; }
      wrap.style.gridTemplateColumns = `repeat(${MODEL.W}, minmax(80px, 1fr))`;
      wrap.innerHTML = '';
      for (let y=0;y<MODEL.H;y++){
        for (let x=0;x<MODEL.W;x++){
          const c = MODEL.cells[y][x];
          const el = document.createElement('div');
          const allZero = c.luts.every(v=> (v|0)===0);
          el.className = 'cell' + (allZero ? ' empty' : '');
          el.onclick = ()=> selectCell(c);
          const coords = document.createElement('div'); coords.className='coords'; coords.textContent = `(${x},${y})`;
          el.appendChild(coords);
          const dirs = document.createElement('div'); dirs.className='dirs';
          const names=['N','E','S','W'];
          for (let i=0;i<4;i++){
            if (!filter[names[i]]) continue;
            const val = showExpr ? c.expr[i] : (showHex ? c.hex[i] : c.luts[i]);
            if (val && val!=='0' && val!==0){
              const span=document.createElement('span'); span.className='dir '+names[i];
              span.textContent = names[i]+'='+String(val);
              dirs.appendChild(span);
            }
          }
          el.appendChild(dirs);
          wrap.appendChild(el);
        }
      }
      document.getElementById('wh').textContent = `${MODEL.W}×${MODEL.H}`;
    }

    function selectCell(c){
      const names=['N','E','S','W'];
      const detail = document.getElementById('detail'); detail.innerHTML='';
      const h = document.createElement('h3'); h.textContent = `Cell (${c.x},${c.y})`; detail.appendChild(h);
      const meta = document.createElement('div'); meta.innerHTML = `<span class='pill'>${MODEL.W}×${MODEL.H}</span>`; detail.appendChild(meta);
      const sec = document.createElement('div');
      for (let i=0;i<4;i++){
        if (!filter[names[i]]) continue;
        const dir = document.createElement('div'); dir.style.marginTop='6px';
        const title = document.createElement('div'); title.innerHTML = `<b class='${names[i]}'>${names[i]}</b>`; dir.appendChild(title);
        const ex = document.createElement('pre'); ex.textContent = 'expr: ' + c.expr[i]; dir.appendChild(ex);
        const hx = document.createElement('pre'); hx.textContent = 'lut : 0x' + c.hex[i] + ' (' + c.luts[i] + ')'; dir.appendChild(hx);
        sec.appendChild(dir);
      }
      detail.appendChild(sec);
    }
    function toggleExpr(){ showExpr=true; showHex=false; renderGrid(); }
    function toggleHex(){ showExpr=false; showHex=true; renderGrid(); }
    function toggleRaw(){ showExpr=false; showHex=false; renderGrid(); }
    function setFilter(id, checked){ filter[id]=checked; renderGrid(); }

    function handleFiles(files){
      if (!files || !files[0]) return;
      const f = files[0];
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const j = JSON.parse(String(reader.result));
          MODEL = tryBuildModel(j);
          renderGrid();
        } catch (e){ alert('Failed to load: '+e.message); }
      };
      reader.readAsText(f);
    }

    async function handleURL(){
      const url = (document.getElementById('url').value||'').trim();
      if (!url) return;
      try{
        const j = await loadJSONFromURL(url);
        MODEL = tryBuildModel(j);
        renderGrid();
      } catch(e){ alert('Fetch failed: '+e.message); }
    }

    function setupDnD(){
      const dz = document.getElementById('drop');
      ['dragenter','dragover','dragleave','drop'].forEach(evt=>{
        dz.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); }, false);
      });
      dz.addEventListener('drop', e=>{ const files = e.dataTransfer.files; handleFiles(files); });
    }

    function setupFromQuery(){
      const p = new URLSearchParams(location.search);
      const file = p.get('file');
      if (file){ document.getElementById('url').value = file; handleURL(); }
    }

    function init(){ setupDnD(); setupFromQuery(); renderGrid(); }
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
